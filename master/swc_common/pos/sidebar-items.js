initSidebarItems({"constant":[["DUMMY_SP","Dummy span, both position and length are zero, syntax context is zero as well. This span is kept inline and encoded with format 0."],["NO_EXPANSION",""]],"enum":[["ExpnFormat","The source of expansion."],["FileName","Differentiates between real files and common virtual files"]],"mod":[["hygiene","Machinery for hygienic macros, inspired by the `MTWT[1]` paper."]],"struct":[["BytePos","A byte offset. Keep this small (currently 32-bits), as AST contains a lot of them."],["ExpnInfo","Extra information for tracking spans of macro and syntax sugar expansion"],["FileMap","A single source in the CodeMap."],["MultiSpan","A collection of spans. Spans have two orthogonal attributes:"],["NameAndSpan",""],["Span","A compressed span. Contains either fields of `SpanData` inline if they are small, or index into span interner. The primary goal of `Span` is to be as small as possible and fit into other structures (that's why it uses `packed` as well). Decoding speed is the second priority. See `SpanData` for the info on span fields in decoded representation."],["SpanData","Spans represent a region of code, used for error reporting. Positions in spans are absolute positions from the beginning of the codemap, not positions relative to FileMaps. Methods on the CodeMap can be used to relate spans back to the original source. You must be careful if the span crosses more than one file - you will not be able to use many of the functions on spans in codemap and you cannot assume that the length of the span = hi - lo; there may be space in the BytePos range between files."],["SyntaxContext","A SyntaxContext represents a chain of macro expansions (represented by marks)."]],"trait":[["Spanned","Derive This trait can be derived with `#[derive(Spanned)]`."]]});