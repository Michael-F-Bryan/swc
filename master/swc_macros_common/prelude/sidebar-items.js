initSidebarItems({"enum":[["Delimiter","Describes how a sequence of token trees is delimited."],["Element","A single syntax tree node of type `T` followed by its trailing punctuation of type `P` if any."],["Pair","A single syntax tree node of type `T` followed by its trailing punctuation of type `P` if any."],["TokenTree","A single token or a delimited sequence of token trees (e.g. `[1, (), ..]`)."]],"macro":[["Token","A type-macro that expands to the name of the Rust type representation of a given token."],["alt","Run a series of parsers, returning the result of the first one which succeeds."],["braces","Parse inside of `{` `}` curly braces."],["brackets","Parse inside of `[` `]` square brackets."],["call","Invoke the given parser function with zero or more arguments."],["cond","Execute a parser only if a condition is met, otherwise return None."],["cond_reduce","Execute a parser only if a condition is met, otherwise fail to parse."],["custom_keyword","Parse the given word as a keyword."],["do_parse","Run a series of parsers, optionally naming each intermediate result, followed by a step to combine the intermediate results."],["epsilon","Parses nothing and always succeeds."],["input_end","Parse nothing and succeed only if the end of the enclosing block has been reached."],["keyword","Parse a single Rust keyword token."],["many0","Parse zero or more values using the given parser."],["map","Transform the result of a parser by applying a function or closure."],["named","Define a parser function with the signature expected by syn parser combinators."],["not","Invert the result of a parser by parsing successfully if the given parser fails to parse and vice versa."],["option","Turn a failed parse into `None` and a successful parse into `Some`."],["parens","Parse inside of `(` `)` parentheses."],["parse_quote","Quasi-quotation macro that accepts input like the [`quote!`] macro but uses type inference to figure out a return type for those tokens."],["punct","Parse a single Rust punctuation token."],["reject","Unconditionally fail to parse anything."],["switch","Pattern-match the result of a parser to select which other parser to run."],["syn","Parse any type that implements the `Synom` trait."],["tuple","Run a series of parsers and produce all of the results in a tuple."],["value","Produce the given value without parsing anything."]],"struct":[["Group","A delimited token stream."],["Literal","A literal string (`\"hello\"`), byte string (`b\"hello\"`), character (`'a'`), byte character (`b'a'`), an integer or floating point number with or without a suffix (`1`, `1u8`, `2.3`, `2.3f32`)."],["Punct","An `Punct` is an single punctuation character like `+`, `-` or `#`."],["Punctuated","A punctuated sequence of syntax tree nodes of type `T` separated by punctuation of type `P`."],["Span","A region of source code, along with macro expansion information."],["TokenStream","An abstract stream of tokens, or more concretely a sequence of token trees."]],"trait":[["ItemImplExt","Extension trait for `ItemImpl` (impl block)."],["PairExt",""],["ToTokens","Types that can be interpolated inside a [`quote!`] invocation."]]});