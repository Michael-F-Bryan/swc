initSidebarItems({"enum":[["Expr","A Rust expression."],["GenericMethodArgument","An individual generic argument to a method, like `T`."],["Member","A struct or tuple struct field accessed in a struct literal or field expression."],["Pat","A pattern in a local binding, function signature, match expression, or various other places."],["RangeLimits","Limit types of a range, inclusive or exclusive."],["Stmt","A statement, usually ending in a semicolon."]],"fn":[["arm_expr_requires_comma",""]],"mod":[["parsing",""],["printing",""]],"struct":[["Arm","One arm of a `match` expression: `0...10 => { return true; }`."],["Block","A braced block containing Rust statements."],["ExprAddrOf","A referencing operation: `&a` or `&mut a`."],["ExprArray","A slice literal expression: `[a, b, c, d]`."],["ExprAssign","An assignment expression: `a = compute()`."],["ExprAssignOp","A compound assignment expression: `counter += 1`."],["ExprBinary","A binary operation: `a + b`, `a * b`."],["ExprBlock","A blocked scope: `{ ... }`."],["ExprBox","A box expression: `box f`."],["ExprBreak","A `break`, with an optional label to break and an optional expression."],["ExprCall","A function call expression: `invoke(a, b)`."],["ExprCast","A cast expression: `foo as f64`."],["ExprCatch","A catch expression: `do catch { ... }`."],["ExprClosure","A closure expression: `|a, b| a + b`."],["ExprContinue","A `continue`, with an optional label."],["ExprField","Access of a named struct field (`obj.k`) or unnamed tuple struct field (`obj.0`)."],["ExprForLoop","A for loop: `for pat in expr { ... }`."],["ExprGroup","An expression contained within invisible delimiters."],["ExprIf","An `if` expression with an optional `else` block: `if expr { ... } else { ... }`."],["ExprIfLet","An `if let` expression with an optional `else` block: `if let pat = expr { ... } else { ... }`."],["ExprInPlace","A placement expression: `place <- value`."],["ExprIndex","A square bracketed indexing expression: `vector[2]`."],["ExprLit","A literal in place of an expression: `1`, `\"foo\"`."],["ExprLoop","Conditionless loop: `loop { ... }`."],["ExprMacro","A macro invocation expression: `format!(\"{}\", q)`."],["ExprMatch","A `match` expression: `match n { Some(n) => {}, None => {} }`."],["ExprMethodCall","A method call expression: `x.foo::<T>(a, b)`."],["ExprParen","A parenthesized expression: `(a + b)`."],["ExprPath","A path like `std::mem::replace` possibly containing generic parameters and a qualified self-type."],["ExprRange","A range expression: `1..2`, `1..`, `..2`, `1..=2`, `..=2`."],["ExprRepeat","An array literal constructed from one repeated element: `[0u8; N]`."],["ExprReturn","A `return`, with an optional value to be returned."],["ExprStruct","A struct literal expression: `Point { x: 1, y: 1 }`."],["ExprTry","A try-expression: `expr?`."],["ExprTuple","A tuple expression: `(a, b, c, d)`."],["ExprType","A type ascription expression: `foo: f64`."],["ExprUnary","A unary operation: `!x`, `*x`."],["ExprUnsafe","An unsafe block: `unsafe { ... }`."],["ExprVerbatim","Tokens in expression position not interpreted by Syn."],["ExprWhile","A while loop: `while expr { ... }`."],["ExprWhileLet","A while-let loop: `while let pat = expr { ... }`."],["ExprYield","A yield expression: `yield expr`."],["FieldPat","A single field in a struct pattern."],["FieldValue","A field-value pair in a struct literal."],["Index","The index of an unnamed tuple struct field."],["Label","A lifetime labeling a `for`, `while`, or `loop`."],["Local","A local `let` binding: `let x: u64 = s.parse()?`."],["MethodTurbofish","The `::<>` explicit type parameters passed to a method call: `parse::<u64>()`."],["PatBox","A box pattern: `box v`."],["PatIdent","A pattern that binds a new variable: `ref mut binding @ SUBPATTERN`."],["PatLit","A literal pattern: `0`."],["PatMacro","A macro in expression position."],["PatPath","A path pattern like `Color::Red`, optionally qualified with a self-type."],["PatRange","A range pattern: `1..=2`."],["PatRef","A reference pattern: `&mut (first, second)`."],["PatSlice","A dynamically sized slice pattern: `[a, b, i.., y, z]`."],["PatStruct","A struct or struct variant pattern: `Variant { x, y, .. }`."],["PatTuple","A tuple pattern: `(a, b)`."],["PatTupleStruct","A tuple struct or tuple variant pattern: `Variant(x, y, .., z)`."],["PatVerbatim","Tokens in pattern position not interpreted by Syn."],["PatWild","A pattern that matches any value: `_`."]]});